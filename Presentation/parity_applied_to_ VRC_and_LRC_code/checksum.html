<section data-auto-animate>
    <h1 class="r-fit-text" style="color: rgb(113, 115, 60);">Checksum</h1>
</section>


<section data-auto-animate>
    <h1 style="color: rgb(113, 115, 60); font-size: 70px;">Checksum</h1>
    <p style="color: rgb(73, 72, 71);">El <strong>checksum</strong> (suma de comprobación) es un mecanismo relativamente sencillo para verificar la integridad de un mensaje.</p>
    <ul style="color: rgb(113, 115, 60);">
        <li>La idea central consiste en ir sumando segmentos de datos de <i>n</i> bits en complemento a 1 de forma que la longitud de la suma sea también <i>n</i> bits, para luego complementar ese total obtenido antes de anexarlo al bloque de datos.</li>
    </ul>
</section>

<section data-auto-animate>
    <h1 style="color: rgb(113, 115, 60); font-size: 70px;">Checksum</h1>
    <img class="r-stretch r-frame" src="assets\images\checksum.png" alt="">
</section>

<section data-auto-animate>
    <h1 style="color: rgb(113, 115, 60); font-size: 60px;">Ejemplo de Cálculo de Checksum</h1>
    <p style="color: rgb(73, 72, 71);">Cálculo de checksum para datos en segmentos de 4 bits:</p>
    <ol style="color: rgb(113, 115, 60); font-size: 24px;">
        <li><strong>Datos:</strong> <code>1011 0011 1101</code></li>
        <li><strong>Paso 1:</strong> Dividimos en segmentos de 4 bits: <code>1011</code>, <code>0011</code>, <code>1101</code></li>
        <li><strong>Paso 2:</strong> Sumamos los segmentos:
            <ul>
                <li><code>1011 + 0011 = 1110</code></li>
                <li><code>1110 + 1101 = 11011</code> (descartamos el bit más alto)</li>
                <li>Resultado: <code>1011</code></li>
            </ul>
        </li>
        <li><strong>Paso 3:</strong> Complemento a 1 de <code>1011</code> es <code>0100</code></li>
        <li><strong>Checksum final:</strong> <code>0100</code></li>
    </ol>
</section>

<section>
    <h1 style="color: rgb(113, 115, 60);">Checksum</h1>
    <p style="color: rgb(73, 72, 71);">Técnica de Detección de Errores</p>
</section>

<!-- Diapositiva 2: Introducción al Checksum -->
<section>
    <h2 style="color: rgb(113, 115, 60);">¿Qué es el Checksum?</h2>
    <p style="color: rgb(73, 72, 71);">El checksum es un valor calculado a partir del contenido de un bloque de datos usando un algoritmo matemático específico.</p>
    <p style="color: rgb(73, 72, 71);">Este valor actúa como un "resumen" de los datos y se adjunta al bloque original para verificar su integridad.</p>
</section>

<!-- Diapositiva 3: Funcionamiento del Checksum -->
<section>
    <h2 style="color: rgb(113, 115, 60);">Funcionamiento del Checksum</h2>
    <ol style="color: rgb(113, 115, 60);">
        <li><strong>Cálculo Inicial:</strong> Se suman segmentos de datos y se complementa el resultado para generar el checksum.</li>
        <li><strong>Transmisión:</strong> El checksum se añade al final del bloque de datos y se envía al receptor.</li>
        <li><strong>Verificación:</strong> En el receptor, se recalcula el checksum y se compara con el original.</li>
    </ol>
</section>

<!-- Diapositiva 4: Ejemplo de Cálculo en Complemento a 1 -->
<section>
    <h2 style="color: rgb(113, 115, 60);">Cálculo en Complemento a 1</h2>
    <p style="color: rgb(73, 72, 71); font-size: 20px;">Supongamos que tenemos un mensaje con los segmentos de 4 bits:</p>
    <p style="font-size: 20px;">\[
    \text{Datos: } 1011 \, 0010 \, 1111 \, 0001
    \]</p>
    <p style="font-size: 20px;"><strong>Paso 1:</strong> Sumar los segmentos:</p>
    <p style="font-size: 20px;">\[
    1011 + 0010 = 1101
    \]
    \[
    1101 + 1111 = 11100 \quad (\text{eliminando el bit que sobrepasa los 4 bits}) = 1100
    \]
    \[
    1100 + 0001 = 1101
    \]</p>
    <p style="font-size: 20px;"><strong>Paso 2:</strong> Complemento a 1 de \( 1101 \):</p>
    <p style="font-size: 20px;">\[
    1101 \rightarrow 0010
    \]</p>
    <p style="font-size: 20px;">El checksum es entonces: \( 0010 \)</p>
</section>

<!-- Diapositiva 5: Usos Comunes del Checksum -->
<section>
    <h2 style="color: rgb(113, 115, 60);">Usos Comunes del Checksum</h2>
    <ul style="color: rgb(113, 115, 60);">
        <li><strong>Protocolos de Red:</strong> Utilizados en IP, TCP, y UDP para detectar errores en la transmisión de datos.</li>
        <li><strong>Transferencia de Archivos:</strong> Verificación de integridad de archivos descargados.</li>
        <li><strong>Almacenamiento de Datos:</strong> Detecta errores en sistemas de almacenamiento como discos duros y sistemas RAID.</li>
    </ul>
</section>

<!-- Diapositiva 6: Ventajas del Checksum -->
<section>
    <h2 style="color: rgb(113, 115, 60);">Ventajas del Checksum</h2>
    <ul style="color: rgb(113, 115, 60);">
        <li><strong>Simplicidad:</strong> Cálculo rápido y fácil de implementar.</li>
        <li><strong>Eficiencia:</strong> Bajo consumo de recursos, adecuado para sistemas embebidos.</li>
        <li><strong>Eficaz en Errores Simples:</strong> Buen desempeño para detectar cambios en pocos bits.</li>
    </ul>
</section>

<!-- Diapositiva 7: Limitaciones del Checksum -->
<section>
    <h2 style="color: rgb(113, 115, 60);">Limitaciones del Checksum</h2>
    <ul style="color: rgb(113, 115, 60);">
        <li><strong>No Detecta Todos los Errores:</strong> Ineficaz ante patrones de errores complejos.</li>
        <li><strong>Sin Capacidad de Corrección:</strong> Solo detecta errores, no los corrige ni identifica su posición.</li>
        <li><strong>Menos Seguro que CRC o Hashes:</strong> Métodos más avanzados como CRC y hashes criptográficos ofrecen mayor precisión y seguridad.</li>
    </ul>
</section>

<!-- Diapositiva 8: Comparación con Otros Métodos -->
<section>
    <h2 style="color: rgb(113, 115, 60);">Comparación con Otros Métodos</h2>
    <table style="width:100%; color: rgb(73, 72, 71); font-size: 20px;">
        <tr>
            <th>Método</th>
            <th>Propósito</th>
            <th>Capacidad de Corrección</th>
        </tr>
        <tr>
            <td>Checksum</td>
            <td>Detectar errores simples</td>
            <td>No</td>
        </tr>
        <tr>
            <td>CRC</td>
            <td>Detectar errores múltiples y en ráfaga</td>
            <td>No</td>
        </tr>
        <tr>
            <td>Código Hamming</td>
            <td>Detectar y corregir errores de un solo bit</td>
            <td>Sí</td>
        </tr>
    </table>
</section>
